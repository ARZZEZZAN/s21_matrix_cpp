# Основные положения ООП

Объектно-ориентированное программирование - методология программирования, основанная на представлении программы в виде совокупности взаимодействующих информационных объектов, принадлежащих определенным классам, выстроенным в иерархическую структуру. 

**Класс** - множество некоторых объектов, имеющие один и тот же набор свойств и методов, определенных над ними. 

**Объект** - конкретный экземпляр класса.

Практически любая часть реального мира может быть представлена некоторой совокупностью формализованных объектов, описывающих эту часть с той точки зрения, которая необходима программисту. Такой подход к разработке приложения и называется объектно-ориентированным. Место, в котором вы сейчас находитесь, также является некоторым объектом класса "место". При этом если данное место рассматривается в рамках приложения, предоставляющего справочную информацию о различных городских заведениях, достаточно ассоциировать с данным объектом только свойства соотвествующие адресу и некоторому типу заведения, набору предоставляемых услуг и т. д. Если же данное место учитывается в рамках приложения отрисовки планарной двумерной карты, потребуются несколько другие свойства, например геопозиция и размеры. Если же требуется визуализировать данное место на экране в трехмерном виде, потребуется перечень достаточно точных описаний визуальных характеристик объектов, находящихся в этом месте, их расположение и размеры относительно друг друга, источники освещения и т. д. Таким образом, один и тот же объект реального или абстрактного мира может быть представлен или смоделирован на программном уровне совершенно различными способами, сохраня только те свойства, которые необходимы. Именно набор этих свойств и определяет в большей степени сами классы. 

Основные принципы ООП:

- Абстракция - выделение того минимального количества характеристик объекта, которые достаточно полно определяют объект с точки зрения разрабатываемой программы.

- Инкапсуляция - сокрытие реализации внутри класса и предоставление внешнего интерфейса для взаимодействия с классом.

- Наследование - иерархическое порождение новых классов на основе уже существующих, полностью или частично переиспользующих реализацию родительского класса.

- Полиморфизм - возможность разных классов, реализующих один интерфейс, иметь разную реализацию.

Исходя из принципа абстракции, объектно-ориентированное программирование приводит к более "естественной" декомпозиции и выделению абстракций. Например, матрица. В случае структурного подхода необходимо определить структуру `struct matrix` и все необходимые функции для работы с этой структурой. В то же самое время, в методологии ООП данная задача решается иначе: создается новый класс объектов - матрица, с которым связаны некоторые поля и функции, называемые методами. При таком подходе, все характеристики матрицы инкапсулированы в некоторой реализации класса и могут быть использованы через сам объект матрицы во время его существования в программе. 

# Обработка исключений

В ООП отличается и подход к обработке исключений. В структурном программирование ключевой стратегией при обработке исключений явлись возвращаемые коды ошибок функций. Они постепенно всплывали в функцию main, которая по большей части должна была состоять из обработчиков ошибок в виде условных операторов разной вложенности. ООП же предлагает использовать систему исключений (exception). Exception это особый класс, который можно "выбрасывать" в случае возникновения ошибочной ситуации в программе. Выброшенное исключение автоматически прервет выполнение текущего метода и начнет "всплывать" стеку вызова до тех пор, пока не окажется в одной области видимости со специальным блоком try-catch. 

Например у нас есть следующий код:

```cpp
#include <iostream>
#include <exception>
 
// division funtion
double divide(double x, double y)
{
    // check division by zero
    if (y == 0)
        // throw standard exception object
        // this will be thrown only if y == 0
        // divide function stops here if y == 0 and returns nothing, but exception
        throw std::exception();
    // perform division
    return x / y;
}
 
int main()
{
    // try block
    // it tries the operation and immediately jumps to the catch block if any exception occurs
    try
    {
        // trying division by zero
        double result = divide(1, 0);
        // this will never happen because y == 0
        std::cout << result << std::endl;
    }
    // catch block
    catch (const std::exception& err)
    {
        // some exception handling here...
    }
    return 0;
}
```

При этом есть возможность создавать пользовательские классы на основе базового класса exception, для того, чтобы различать типы исключений или передавать дополнительную информацию вместе с объектом исключения. Для этого можно создать свой класс исключений и унаследовать его от `std::exception`. 

# Структура класса

В языке C++ классы напоминают структуры:

```cpp
class <имя класса> 
{
  <модификатор доступа>:
      <атрибут или метод>
};
```

Однако вместо полей здесь атрибуты, определяемые как простые переменные. Так же, внутри класса можно определять методы - функции, имеющие доступ ко всем атрибутам класса. Методы и атрибуты неразрывно связаны с классом. Модификаторы доступа (public, protected и private) регулируют внешний доступ к методам и атрибутам класса: приватные атрибуты и методы доступны только изнутри класса, в то время как публичные - доступны из любой внешней функции или другого класса. Приватные атрибуты позволяют скрыть от пользователя реализацию внутренних полей и предоставить безопасные публичные методы доступа (accessor) и изменения (mutator). Обычно, для доступа к приватному атрибуту `x`, определяются публичные методы `getX()` - accessor и `setX()` - mutator.

Для непосредственного доступа к атрибутам или методам используется синтаксис, повторяющий синтаксис обращения к полям структуры. Например `myObject.myArgument` вернет значение атрибута `myArgument` из объекта `myObject`, а `myObject.myMethod()` выполнит метод `myMethod()` объекта `myObject`. В случае использования указателя на объект, используется аналогичный указателям на структуры синтаксис обращения к аргументам и методам. Например `myObjectPointer->myMethod()` вызовет метод `myMethod()` объекта, на который указывает `myObjectPointer`. 

У класса так же могут быть определены специальные методы, называемыми конструкторами и деструкторами. Они вызываются автоматически при создании и удалении объекта данного класса. В них выделяются и заполняются необходимые поля или же наоборот - освобождаются.

Для того чтобы объявить конструктор, нужно указать метод с именем класса без типа возвращаемого значения, например:

```cpp
Matrix();
```

Деструктор объявляется схожим образом, но начинается с тильды:

```cpp
~Matrix();
```

C++ позволяет создавать несколько конструкторов для одного класса с различным набором аргументов, при создании объектов данного класса будет вызван либо конструктор, соответствующий передаваемым аргументам, либо, если аргументы не были переданы, конструктор по умолчанию:

```cpp
Matrix();               // конструктор по умолчанию
Matrix(int n);          // конструктор с одним аргументом, например, он создает квадратную матрицу размером n на n
Matrix(int n, int m);   // конструктор с двумя аргументами, например, он создает матрицу размером n на m
```

Вызов этих конструкторов в коде программы:

```cpp
int n = 4, m = 5;
Matrix m1;               // конструктор по умолчанию
Matrix m2(n);            // конструктор с одним аргументом, например, он создает квадратную матрицу размером n на n
Matrix m3(n, m);         // конструктор с двумя аргументами, например, он создает матрицу размером n на m
```

Не стоит пытаться вызвать метод конструктора повторно уже как обычный метод созданного объекта. Конструкторы используются только для создания нового объекта. 

Для создания указателя на объект, используется ключевое слово `new`:

```cpp
Matrix* pM = new Matrix(4,5);
```

Обратите внимание, что скобки с передаваемыми аргументами теперь ставятся после наименования класса, а не переменной. Для ручного удаления объекта, на который указывает `pM` можно воспользоваться ключевым словом `delete`:

```cpp
delete pM;              // тут автоматически вызовется деструктор ~Matrix()
```

Если объект был создан не через new, а простым объявлением, то деструктор вызовется при выходе из области видимости, в которой была создана данная переменная:

```cpp
int main() {
    Matrix m(4);

    // Какие-то операции над матрицей, вызовы функций и методов...

    return 0;           // тут автоматически вызовется деструктор
}
```

Помимо конструктора по умолчанию (конструктора с пустым набором входных параметров), есть еще два специальных конструктора: конструктор копирования и конструктор перемещения. Конструктор копирования предназначен для инициализации объекта путем копирования всех атрибутов другого объекта того же класса в новый объект. В качестве аргумента он содержит ссылку на копируемый объект. Конструктор перемещения выглядит почти так же, как и конструктор копирования, но ожидается, что он очистит атрибуты перемещаемого объекта. В качестве параметра он содержит двойную ссылку на перемещаемый объект. Конструктор перемещения обычно выполняется в те случаи, когда перемещаемый объект будет в скором времени уничтожен. Подробнее, можно посмотреть в примере в `code-samples`. Конструкторы копирования и перемещения имеют следующий вид:

```cpp
Matrix (Matrix&);       // конструктор копирования
Matrix (Matrix&&);      // конструктор перемещения
```

В C++, как и в C, помимо обычных файлов с кодом (.cpp/.cc) есть еще и заголовочные файлы (.h). Напоминаем, что код из заголовочных файлов автоматически копируется в исходный код на этапе препроцессирования при каждой встрече компилятором директивы `#include`. Как прежде, заголовочные файлы служат для объявления имен, на которые будут ссылаться другие участки кода. Масштабируя это понятие на объектно-ориентированную парадигму, получаем, что в наиболее частом случае в заголовочном файле объявляется класс и его методы. Заголовочные файл не должны содержать реализации методов классов или каких-либо обособленных функций.

На контрасте с C, с C++ также связано и понятия области пространства имен. Пространство имен — это область, в рамках которой определяются различные идентификаторы (имена типов, функций, переменных, и т. д.), ассоциированные друг с другом. Пространства имен используются для логического объединения кода в тематическую группу и избегания конфликтов одинаковых имен, имеющих различное контекстуальное значение. Намного легче это понять на примере. Например, в какой-то обширной программе потребовалось описать два класса для деревьев, но разных: в одном случае, например, класс описывает какие-то ботанические характеристики деревьев, как растений, а в другом случае, например, является иерархическим представлением родословной. Вполне ясно, что можно придумать различные имена этим классам, но это необязательно. Из контекста очевидно, что классы относятся к разным сущностям и реализуют разную логику. Можно ввести две разные области имен, например, `Botany` и `Family`, в которые потенциально может входить огромное число других различных классов, ассоциированных с этими понятиями. Выглядеть это будет примерно так:

```cpp
namespace Botany
{
    class Tree
    {
        // класс представляющий дерево как растение
    }
}
```

```cpp
namespace Family
{
    class Tree
    {
        // класс представляющий родословное дерево
    }
}
```

Теперь для обращения к этим классам вне соответствующей области имен достаточно использовать следующий синтаксис `<Имя области имен>::<имя>`, например: для обращения к родословному дереву мы получим `Family::Tree`. Области имен могут иметь сложную иерархическую структуру, то есть некоторые из областей имен могут быть определены внутри других, и тогда, при обращении, они должны быть перечислены в порядке вложенности. Чтобы не писать имя области имен каждый раз в случае в случаях, когда о конфликтах не стоит беспокоиться, можно использовать ключевое слово `using`.

# Перегрузка

Перегрузка - это возможность создавать несколько **различных** функций и методов с одним и тем же именем, но разными аргументами и типами возвращаемого значения. Это может понадобиться, например, если есть потребность создать универсальную функцию. Например, нам требуется создать функцию для сложения двух чисел. Ее прототипом может быть следующая функция:

```cpp
int sum(int a, int b);
```

В C приходилось создавать отдельные реализации функций для различных типов, например:

```c
int sum_integer(int a, int b);
double sum_double(double a, double b);
```

Но в C++ появилась возможность перегружать функции, то есть определять разные функции с одним и тем же именем:

```cpp
int sum(int a, int b);              // будет вызвана в случае, если будут переданы два значения типа int
double sum(double a, double b);     // будет вызвана в случае, если будут переданы два значения типа double
```

При этом есть возможность определить функцию `sum` и для большего числа параметров:

```cpp
int sum(int a, int b, int c);        // будет вызвана в случае, если будут переданы три значения типа int
```

# Перегрузка операторов

Объектно-ориентированное программирование так же сделало возможным перегрузку операторов. Для любого нового класса может быть определен любой стандартный оператор (бинарный или унарный). Например, умножение. Возникла потребность определить умножение объекта на матрицу не через функцию `mult(Matrix, Matrix)`, а через оператор `*`. Это бинарный оператор, левая и правая части которого представляются матрицами:

```cpp
Matrix operator*(Matrix& x);
``` 

Умножение матрицы на число также может быть определено через тот же самый оператор, но в методе с другой сигнатурой, например:

```cpp
Matrix operator*(double x);
``` 

Внимание! Этот метод будет срабатывать только в случае, если матрица умножается на число (именно в таком порядке). Это связано с тем, что любой бинарный оператор в C++ раскрывается как оператор между первым и вторым операндом, при этом выполняется реализация того оператора, которая объявлена у первого операнда. Переменная с типом double "не знает" о том, как производится умножения на матрицу. Решить эту проблему можно следующим образом. Использовать оператор с двумя аргументами, но определить его **вне класса**. Тогда аргументы будут восприниматься как соответствующие операнды. В таком случае, придется сделать две копии перегруженного оператора с различным порядком аргументов, например:

```cpp
Matrix operator*(double, Matrix&);
Matrix operator*(Matrix&, double);
```

Для того, чтобы связать эти функции с классом Matrix, достаточно определить указанные операторы как **дружественные** уже **внутри класса** следующим образом:

```cpp
friend Matrix operator*(double, Matrix&);
friend Matrix operator*(Matrix&, double);
```

Перегружая операторы, стоит всегда помнить следующие правила:

- Нельзя перегрузить несуществующие в C++ операторы.

- Нельзя перегрузить операторы, если ни один из участвующих в нем операндов не является переменной пользовательского типа;

- При перегрузке операторов остается установленный в C++ приоритет для этой операции и на это нельзя повлиять;

- Нельзя изменить количество операндов, предусмотренных оператором.

Это и называется перегрузкой оператора - использование нескольких различных реализаций оператора в зависимости от подаваемой сигнатуры. 

# Правило пяти

`Правило пяти` говорит о том, что в общем случае, если возникла необходимость самостоятельного определения одной из операций копирования, перемещения или разрушения объекта, то скорее всего для корректной работы нужно будет реализовать:

- Деструктор
- Конструктор копирования
- Оператор присваивания копированием
- Конструктор перемещения
- Оператор присваивания перемещением

Пример правила пяти:

```
#include <cstring>

class RFive
{
private:
    char* cstring;

public:
    // Конструктор со списком инициализации и телом
    RFive(const char* arg)
    : cstring(new char[std::strlen(arg)+1])
    {
        std::strcpy(cstring, arg);
    }

    // Деструктор
    ~RFive()
    {
        delete[] cstring;
    }

    // Конструктор копирования
    RFive(const RFive& other)
    {
        cstring = new char[std::strlen(other.cstring) + 1];
        std::strcpy(cstring, other.cstring);
    }

    // Конструктор перемещения, noexcept - для оптимизации при использовании стандартных контейнеров
    RFive(RFive&& other) noexcept 
    {
        cstring = other.cstring;
        other.cstring = nullptr;
    }

    // Оператор присваивания копированием (copy assignment)
    RFive& operator=(const RFive& other) 
    {
        if (this == &other)
            return *this;

        char* tmp_cstring = new char[std::strlen(other.cstring) + 1];
        std::strcpy(tmp_cstring, other.cstring);
        delete[] cstring;
        cstring = tmp_cstring;
        return *this;
    }

    // Оператор присваивания перемещением (move assignment)
    RFive& operator=(RFive&& other) noexcept
    {
        if (this == &other)
            return *this;

        delete[] cstring;
        cstring = other.cstring;
        other.cstring = nullptr;
        return *this;
    }

//  Также можно заменить оба оператора присваивания следующим оператором
//  RFive& operator=(RFive other)
//  {
//      std::swap(cstring, other.cstring);
//      return *this;
//  }
};
```
